ram: 256B
0-253: data
254: flags
255: pc

flags:
error (carry), ==0, <0

instructions: 1B opcode, 2*1B arguments

opcode:
2b op, 1b first argument is pointer, 1b second argument is literal, 1b set flags, 1b execute if error flat, 2b execute if sign flags

op:
mov
add
nor
and

sign flags: 1b if <0, 1b if ==0
00 always
01 ==0
10 <0
11 <=0

halt if pc>=252

compilable format:
<op> [arguments ...] [flags]
argument format:
0  value of cell 0
'0 literal 0
*0 value of cell pointed by cell 0
&0 reference to instruction 0
values can also be negative, hexadecimal, binary or octal, specified with -, x, b, or o before the number
instead of a number the value can be a single character after c
flags:
f set flags
e execute if error flag is set
< execute if <0 flag is set
= execute if =0 flag is set
native ops:
mov <dst> <src>
add <dst> <src>
nor <dst> <src>
and <dst> <src>
compiled ops:
var <initial value>
inc <dst>
dec <dst>
jmp <dst>
hlt
rse automatically resets err flag
rsn automatically resets neg flag
rsz automatically resets zero flag
not <dst>
chk <dst>, doesn't automatically sets the flags
neg <dst>
sub <dst> <src>, src can't be a literal
cmp <dst> <src>, src can't be a literal, checks dst-src without changing dst, doesn't automatically sets the flags
cma <dst> <src>, src can't be a literal, checks dst+src without changing dst, doesn't automatically sets the flags
cmx <dst> <src1> <src2>, checks dst+src1, sets dst to dst+src1+src2, doesn't automatically sets the flags